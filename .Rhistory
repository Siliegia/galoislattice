Bonus.f <- num2factor(Bonus)
poisson.inter(y = Claims, n = Insured, x1 = Bonus.f$y.num, x2 = Make.new, label1 = "Bonus",
label2 = "Make")
Bonus.f$y.num
poisson.inter(y = Claims, n = Insured, x1 = Zone.new, x2 = Bonus, label1 = "Zone",
label2 = "Bonus")
poisson.inter(y = Claims, n = Insured, x1 = Kilometres.new, x2 = Make.new, label1 = "Kilometres",
label2 = "Make")
poisson.inter(y = Claims, n = Insured, x1 = Zone.new, x2 = Make.new, label1 = "Zone",
label2 = "Make")
model.inter <- glm(Claims ~ Kilometres.new + Make.new + Bonus + Zone.new, family = poisson(link = "log"),
data = insurance, offset = log(Insured))
model.inter <- glm(Claims ~ (Kilometres.new + Make.new + Bonus + Zone.new)^2, family = poisson(link = "log"),
data = insurance, offset = log(Insured))
summary(model.inter)
step(model.main,direction = "forward" ,k = 2 )
model.inter2 <- step(model.main,direction = "forward" ,k = 2 )
summary(model.inter2)
length(insurance$Claims)
length(model.main$coefficients)
n2 <- length(insurance$Claims)-length(model.inter$coefficients)
n1
n1 <- length(insurance$Claims)-length(model.main$coefficients)
n2 <- length(insurance$Claims)-length(model.inter$coefficients)
n1
n2
1 - pchisq(model.main$deviance - model.inter$deviance,n1-n2)
qchisq(.9,n1-n2)
dev.diff <- model.main$deviance - model.inter$deviance
dev.diff
chi <- qchisq(.9,n1-n2)
dev.diff > chi
dev1 <- model.main$deviance
dev2 <- model.inter$deviance
chi1 <- qchisq(.9,n1)
chi2 <- qchisq(.9,n2)
dev1>chi1
dev2>chi2
pearson <- resid(object = model.inter, type = "pearson")
pearson <- resid(object = model.inter, type = "pearson")
dev.res <- resid(model.inter, type = "deviance")
plot(pearson)
par(mfrow = c(2,1))
plot(pearson)
par(mfrow = c(1,2))
pearson <- resid(object = model.inter, type = "pearson")
dev.res <- resid(model.inter, type = "deviance")
plot(pearson)
plot(dev.res)
yhat <- predict(model.inter)
model.inter2 <- step(model.main, ~.^2, method = "forward" )
length(model.main$coefficients
)
n1
n2
range.pres1<-max(abs(pearson))
range.pres1
?fitted
?tapply
fit <- fitted(model.inter)
fit
Var(Claims)
var(Claims)
mean(Claims)
var(Claims/Insured)
mean(Claims/Insured)
Dev.inter <- model.inter$deviance
p.inter <- model.inter$df.residual
Dev.inter > p.inter
Dev.inter
p.inter
?glm.nb
library(MASS)
model.inter.dis <- glm.nb(Claims ~ (Kilometres.new + Make.new + Bonus + Zone.new)^2, data = insurance)
model.inter.dis <- glm.nb(Claims ~ (Kilometres.new + Make.new + Bonus + Zone.new)^2, data = insurance,
offset = log(Insured))
model.inter.dis <- glm.nb(Claims ~ offset = log(Insured) + (Kilometres.new + Make.new + Bonus + Zone.new)^2
, data = insurance)
model.inter.dis <- glm.nb(Claims ~ offset = log(Insured) + (Kilometres.new + Make.new + Bonus + Zone.new)^2)
model.inter.dis <- glm.nb(Claims ~ offset(log(Insured)) + (Kilometres.new + Make.new + Bonus + Zone.new)^2)
offset(log(Insured))
?offset
dev.dis <- deviance(model.inter.dis)
dev.dis
p.inter.dis <- model.inter.dis$df.residual
qchisq(.95,p.inter.dis)
chi <- qchisq(.95,p.inter.dis)
dev.dis > chi
1 - pchisq(dev.dis,p.inter.dis)
dev.dis > chi
summary(model.inter.dis)
plot(resid(model.inter.dis, type = "pearson"))
plot(resid(model.inter.dis, type = "deviance"))
which(Claims == 0)
insurance.new <- insurance[which(Claims == 0),]
Payment
Y <- Payment/Claims
source('C:/Users/Maria/Desktop/MO/Master/2.Master/GLM/gamma.main.R')
gamma.main(y = Y, x = Kilometres, label = "Kilometres")
gamma.main(Y, Kilometres, "Kilometres")
source('C:/Users/Maria/Desktop/MO/Master/2.Master/GLM/gamma.main.R')
gamma.main(Y, Kilometres, "Kilometres")
Kilometres=factor(Kilometres)
Make=factor(Make)
Zone=factor(Zone)
gamma.main(Y, Kilometres, "Kilometres")
Kilometres.new <- Kilometres
unique(Kilometres)
Kilometres.new <- Kilometres.new[Kilometres.new == 4] = 2
Kilometres.new == 4
Kilometres.new <- Kilometres.new[Kilometres == 4] = 2
K=Kilometres
levels(K)[4]="2"
levels(K)[4]=c("4")
K
B = Bonus
levels(B)[3] = "1"
M=Make
levels(M)[4]="2"
levels(M)[4:7]=c("4","5","6","7")
levels(M)[8]=c("7")
par(mfrow=c(1,3))
gamma.main(Y,K,"Kilometres")
gamma.main(Y,Z,"Zone")
Z=Zone
levels(Z)[7]="1"
gamma.main(Y,K,"Kilometres")
?glm
model.main<-glm(Y~K+Bonus+M+Z,family=Gamma(link="log"),weights=Claims)
summary(model.main)
dev.gamma <- model.main$deviance
p.ga <- model.main$df.residual
1-pchisq(dev.gamma, p.ga)
chi <- qchisq(.95,p.ga)
dispersion <- summary(model.main)$dispersion
dispersion
dev.gamma/dispersion > chi
dev.gamma
dispersion
chi
dev.gamma/dispersion
1-pchisq(dev.gamma/dispersion, p.ga)
species <- c(1,1,1,1,0,0,0,0)
PD <- c(1,0,1,0,1,0,1,0)
specie <- c(1,1,1,1,0,0,0,0)
PD <- c(1,0,1,0,1,0,1,0)
PH <- c(1,1,0,0,1,1,0,0)
W <- c(86,35,32,11,73,70,61,41)
X <- cbind(specie,PD,PH,W)
X
dat <- cbind(expand.grid(Species = c("Anoli", "Disticus"),
PD = c("small","large"),
PH = c("high", "low")),
FREQ = c(32, 61, 11, 41, 86, 73, 35, 70))
dat <- cbind(expand.grid(Species = c("Anoli", "Disticus"),
PD = c("small","large"),
PH = c("high", "low")),
FREQ = c(32, 61, 11, 41, 86, 73, 35, 70))
attach(dat)
dat
table(dat$Speciesmdat$)
table(dat$Speciesmdat$)
table(dat$Species,dat$FREQ)
aggregate(dat$Species,list(dat$FREQ),sum)
tab_species_PH<-tapply(FREQ,list(PH,Species),sum)
tab_species_PH
compute.odds=function(mytab)
{
odd= mytab[1,1]*mytab[2,2]/(mytab[1,2]*mytab[2,1])
return(odd)
}
odds.ph.spec <- compute.odds(tab_species_PH)
odds.ph.spec
tab_Species_PD <- tapply(FREQ,list(PD,Species),sum)
tab_Species_PD
?tapply
odds.pd.spec <- compute.odds(tab_Species_PD)
odds.pd.spec
tab_Species_PD <- tapply(FREQ,list(PD,Species),sum)
tab_Species_PD
dat <- cbind(expand.grid(Species = c("Anoli", "Disticus"),
PD = c("small","large"),
PH = c("high", "low")),
FREQ = c(32, 61, 11, 41, 86, 73, 35, 70))
attach(dat)
dat
PD
tab_species_PH<-tapply(FREQ,list(dat$PH,dat$Species),sum)
odds.ph.spec <- compute.odds(tab_species_PH)
odds.ph.spec
tab_Species_PD <- tapply(FREQ,list(dat$PD,dat$Species),sum)
tab_Species_PD
odds.pd.spec <- compute.odds(tab_Species_PD)
odds.pd.spec
tab_PH_PD <- tapply(FREQ,list(dat$PD,dat$PH),sum)
odds.pd.ph <- compute.odds(tab_PH_PD)
odds.pd.ph
poisson.main(y = FREQ, n = 1, x = dat$Species, label = "Species")
par(mfrow = c(2,2))
poisson.main(y = FREQ, n = 1, x = dat$Species, label = "Species")
poisson.main(y = FREQ, n = 1, x = dat$PD, label = "PD")
poisson.main(y = FREQ, n = 1, x = dat$PH, label = "PH")
poisson.inter(y = FREQ, n = 1, x1 = dat$Species, x2 = dat$PD, label1 = "Species", label2 = "PD")
poisson.inter(y = FREQ, n = 1, x1 = dat$Species, x2 = dat$PD, label1 = "Species", label2 = "PD")
poisson.inter(y = FREQ, n = 1, x1 = dat$PH, x2 = dat$PD, label1 = "PH", label2 = "PD")
poisson.inter(y = FREQ, n = 1, x1 = dat$Species, x2 = dat$PH, label1 = "Species", label2 = "PH")
?glm
Model.A <- glm(FREQ~ Species + PD + PH, family=poisson, x=T)
summary(Model.A)
Model.B <- glm(FREQ~ Species + PD + PH + PH:PD, family=poisson, x=T)
1 - pchisq(Model.A$deviance,Model.A$df.residual)
Model.A$deviance
Model.A$df.residual
Model.A <- glm(FREQ~ Species + PD + PH, family=poisson, x=T)
summary(Model.A)
Model.A <- glm(FREQ~ dat$Species + dat$PD + dat$PH, family=poisson, x=T)
summary(Model.A)
1 - pchisq(Model.A$deviance,Model.A$df.residual)
Model.A$deviance > qchisq(0.95,Model.A$df.residual)
Model.B <- glm(FREQ~ dat$Species + dat$PD + dat$PH +dat$PH:dat$PD, family=poisson, x=T)
1 - pchisq(Model.B$deviance,Model.B$df.residual)
Model.B$deviance > qchisq(0.95,Model.B$df.residual)
Model.C <- glm(FREQ~ dat$Species + dat$PD + dat$PH + dat$Species:dat$PD + dat$Species:dat$PH, family=poisson, x=T)
1 - pchisq(Model.C$deviance,Model.C$df.residual)
Model.C$deviance > qchisq(0.95,Model.C$df.residual)
source('C:/Users/Maria/Desktop/MO/Master/2.Master/GLM/Problem 11functions.R')
credit <- read.table('C:\\Users\\Maria\\Desktop\\MO\\Master\\2.Master\\GLM\\credit.txt',header = TRUE)
attach(credit)
laufkontf <- factor(laufkont, ordered = TRUE)
moralf <- factor(moral, ordered = TRUE)
buergef <- factor(buerge, ordered = FALSE)
table(laufkontf,kredit)
table(moralf,kredit)
main1.plot(y = kredit, covar = alter.cut$y.num ,covar.lab = alter.cut$y.cut)
par(mfrow = c(2, 2))
alter.cut <- num2factor(alter)
laufzeit.cut <- num2factor(laufzeit)
main1.plot(y = kredit, covar = alter.cut$y.num ,covar.lab = alter.cut$y.cut)
BinaryReg <- glm(kredit ~ laufkontf+moralf+buergef+laufzeit+alter,family=binomial(link = "logit"))
summary(BinaryReg) #alle auÃŸer alter werden abgelehnt
small.model <- glm(kredit ~ buerge+moral+laufkont, data = N.credit,family = binomial (link = "logit"))
N.credit <- cbind(kredit,laufkont,moral,buerge)
laufkont <- factor(laufkont, ordered = TRUE)
moral <- factor(moral, ordered = TRUE)
buerge <- factor(buerge, ordered = FALSE)
N.credit <- as.data.frame(N.credit)
N.credit$laufkont <- as.factor(N.credit$laufkont)
N.credit$moral <- as.factor(N.credit$moral)
N.credit$buerge <- as.factor(N.credit$buerge)
small.model <- glm(kredit ~ buerge+moral+laufkont, data = N.credit,family = binomial (link = "logit"))
leverage <- hatvalues(small.model)
length(which(leverage > 2*sum(leverage)/length(leverage)))
plot(leverage)
abline(2*sum(leverage)/length(leverage),0)
data.aggr <- aggregate(kredit,by = list(laufkont,moral,buerge),sum) #41
data.aggr
M1=matrix(c(1,1,1,0,0,0,
0,0,0,1,1,1,
1,0,0,1,0,0,
1,1,0,1,0,1),nrow=6)
library(galoislattice)
Z <- do_galois_lattice(M1)
library(igraph)
Z <- do_galois_lattice(M1)
M1
M1=matrix(c(1,1,1,0,0,0,
0,0,0,1,1,1,
1,0,0,1,0,0,
1,1,0,1,0,1),nrow=6)
colnames(M1) <- c("A", "B", "C", "D")
rownames(M1) <- as.character(1:6)
M1=matrix(c(1,1,1,0,0,0,
0,0,0,1,1,1,
1,0,0,1,0,0,
1,1,0,1,0,1),nrow=6)
colnames(M1) <- c("A", "B", "C", "D")
rownames(M1) <- as.character(1:6)
libr
library(galoislattice)
Z <- do_galois_lattice(M1)
library(galoislattice)
?do_galois_lattice
Y <- read.graph(file.choose(), format = "pajek")
V(Y)$name = V(Y)$id
Z <- do_galois_lattice(Y, label = "reduced")
plot(Z)
plot(Z, layout = galois_layout(Z))
system.time(Z <- do_galois_lattice(Y, label = "reduced"))
system.time(Z <- do_galois_lattice(Y, label = "full"))
system.time(Z <- do_galois_lattice(Y, label = "partly"))
system.time(Z <- do_galois_lattice(Y, label = "partly", by = "col"))
system.time(Z <- do_galois_lattice(Y, label = "partly", by = "row"))
system.time(Z <- do_galois_lattice(Y, label = "reduced", by = "row"))
plot(Z, layout = galois_layout(Z))
system.time(Z <- do_galois_lattice(Y))
?do_galois_lattice
library(glmnet)
?glmnet
?do_galois_lattice
library(galoislattice)
?do_galois_lattice
M=matrix(c(1,1,1,0,0,0,
0,0,0,1,1,1,
1,0,0,1,0,0,
1,1,0,1,0,1),nrow=6)
colnames(M) <- c("A", "B", "C", "D")
rownames(M) <- as.character(1:6)
Galois <- do_galois_lattice(M)
plot(Galois)
plot(Galois, layout = galois_layout(Galois))
Galois <- do_galois_lattice(M,label = "reduced")
plot(Galois, layout = galois_layout(Galois))
Galois <- do_galois_lattice(M,label = "full")
plot(Galois, layout = galois_layout(Galois))
Galois <- do_reduced_label(Galois, M)
plot(Galois, layout = galois_layout(Galois))
T <- do_dominance_tree(Galois, 0, 1, 1:6)
T <- do_dominance_tree(Galois, "0", "1", 1:6)
plot(T)
plot(Galois)
Galois <- do_galois_lattice(M, directed = TRUE, label = "reduced")
plot(Galois, layout = galois_layout(Galois))
Galois <- do_galois_lattice(M, directed = TRUE, label = "reduced",, by = "col")
Galois <- do_galois_lattice(M, directed = TRUE, label = "reduced", by = "col")
plot(Galois, layout = galois_layout(Galois))
Galois <- do_galois_lattice(M, directed = TRUE, label = "reduced", by = "row")
plot(Galois, layout = galois_layout(Galois))
load("C:/Users/Maria/Desktop/MO/Master/Masterarbeit/Daten/MixedSpecies.RData")
mixedSpeciesdata <- mixedSpecies100
human.simData <- mixedSpeciesdata[grep("HUMAN",rownames(mixedSpeciesdata)),]
mouse.simData <- mixedSpeciesdata[grep("MOUSE",rownames(mixedSpeciesdata)),]
simData <- rbind(human.simData,mouse.simData)
human.counts <- colSums(human.simData != 0)
mouse.counts <- colSums(mouse.simData != 0)
mixed.cells <- sort(abs(human.counts - mouse.counts))[1:5]
mixed.cells <- names(mixed.cells)
simData <- simData[,!(names(simData) %in% mixed.cells)]
human.counts <- human.counts[!(names(human.counts) %in% mixed.cells)]
mouse.counts <- mouse.counts[!(names(mouse.counts) %in% mixed.cells)]
human.cells <- colnames(simData)[which(human.counts > mouse.counts)]
mouse.cells <- colnames(simData)[which(human.counts < mouse.counts)]
human.cell.simData <- simData[,which(human.counts > mouse.counts)]
mouse.cell.simData <- simData[,which(human.counts < mouse.counts)]
human.cells <- unlist(lapply(human.cells, function(x){ toString(c("HUMAN",x))}))
mouse.cells <- unlist(lapply(mouse.cells, function(x){ toString(c("MOUSE",x))}))
colnames(mouse.cell.simData) <- mouse.cells
colnames(human.cell.simData) <- human.cells
simData <- cbind(human.cell.simData, mouse.cell.simData)
local.means.human <- data.frame(rowMeans(human.simData))
names(local.means.human) <- c("rowMeans")
rownames(local.means.human)[order(local.means.human$rowMeans, decreasing = TRUE)[1:100]] -> selectedGenes.human
local.means.mouse <- data.frame(rowMeans(mouse.simData))
names(local.means.mouse) <- c("rowMeans")
rownames(local.means.mouse)[order(local.means.mouse$rowMeans, decreasing = TRUE)[1:100]] -> selectedGenes.mouse
simData.human <- simData[selectedGenes.human,]
simData.mouse <- simData[selectedGenes.mouse,]
simData <- rbind(simData.human,simData.mouse)
source('C:/Users/Maria/Desktop/MO/Master/2.Master/ComputationalBiology/gene-expression/R/kknn-functions.R')
source('C:/Users/Maria/Desktop/MO/Master/2.Master/ComputationalBiology/gene-expression/R/mixedSpeciesKknn.R')
magic <- function(D, ka = 3, pc = 20, t = 3){
D <- t(D) #cells in rows
#data preprocessing
#data normalization
Libsize <- rowSums(D) # library size
D.n <- D/matrix(Libsize, nrow = dim(D)[1], ncol = dim(D)[2]) * median(Libsize)
#PCA
D.fpc <- t(D)
C <- 1/dim(D.fpc)[1] * D.fpc%*%t(D.fpc)
Z <- eigen(C, symmetric = TRUE)
V <- Z$vectors
D.pc <- t(V[,1:pc]) %*% D.fpc
D.pc <- t(D.pc)
#Compute Distance Matrix
Dist <- as.matrix(dist(D.pc, method = "euclidean"))
#Choose appropriate ka to Calcualte Affinity Matrix
sig <- matrix(0, nrow = dim(Dist)[1], ncol = 1)
for (i in 1:dim(Dist)[1]){sig[i] <- sort(Dist[i,])[ka]}
sig <- matrix(sig, nrow = dim(Dist)[1], ncol = dim(Dist)[1])
A <- exp(-(Dist/sig)^2)
A <- A + t(A)
#Calculating Markov Matrix
M <- A/matrix(rowSums(A), nrow = dim(A)[1], ncol = dim(A)[2])
#Imputing value with right choice of t
D.n <- as.matrix(D.n)
D.imp <- M%*%M%*%M%*%M%*% D.n # package expm
#rescale result
for (i in 1 : dim(D)[1]){
D.imp[i,] <- D.imp[i,] * quantile(D[i,],.99)/max(D.imp[i,])}
return(t(D.imp))
}
library(kknn)
lasso.mixed.data <- function(ID,simData, genes = FALSE){
i = which(colnames(simData)==ID)
#formate for lasso function
simData <- as.matrix((simData))
#define test and learn data
simData.test <- simData[which(simData[,i]==0),,drop=FALSE] # define all zero entries of ID as test
simData.learn <- simData[-c(which(simData[,i]==0)),,drop=FALSE] # define all non-zero entries as learn
# take out ID from the data set for analysis
simData_learn <- simData.learn[,-c(which(colnames(simData.learn)==ID)),drop = FALSE]
simData_test <- simData.test[,-c(which(colnames(simData.test)==ID)),drop = FALSE]
#define the vector ID for analysis
vec.learn <- simData.learn[,which(colnames(simData.learn)==ID)]
vec.test <- simData.test[,which(colnames(simData.test)==ID)]
n = dim(simData_learn)[1] # number of non-zero entries
if (n > 2){ #if there is more than one entry non zero do regression
fit.expr.lin <- glmnet(x = log(1+simData_learn), y = log(1+vec.learn),
family = "gaussian", standardize = TRUE, alpha = 1)
if (genes){
lambda = 0.0058
}else{
lambda = 0.0185 }
prediction <- predict(fit.expr.lin, newx = log(1+simData_test), s = lambda)
prediction <- exp(prediction)-1
}else{
prediction <- rep(0, nrow(simData.test))
}
outputVector <- simData[,ID]
outputVector[which(simData[,ID]==0)] <- prediction
return(outputVector)
}
library(glmnet)
rc <- mapply(lasso.mixed.data, colnames(simData), MoreArgs = list((simData)))
simData2 <- simData
colnames(simData2) <- gsub("[ ,]", "", colnames(simData2), perl = TRUE)
td <- mapply(kknn.mixed.data, colnames(simData2),
MoreArgs = list(as.data.frame(simData2)))
fit.expr.lin <- glmnet(x = log(1+simData_learn), y = log(1+vec.learn),
family = "gaussian", standardize = TRUE, alpha = 1)
?glmnet
ID <- colnames(simData)[3]
i = which(colnames(simData)==ID)
simData <- as.matrix((simData))
simData.test <- simData[which(simData[,i]==0),,drop=FALSE] # define all zero entries of ID as test
simData.learn <- simData[-c(which(simData[,i]==0)),,drop=FALSE] # define all non-zero entries as learn
simData_learn <- simData.learn[,-c(which(colnames(simData.learn)==ID)),drop = FALSE]
simData_test <- simData.test[,-c(which(colnames(simData.test)==ID)),drop = FALSE]
vec.learn <- simData.learn[,which(colnames(simData.learn)==ID)]
vec.test <- simData.test[,which(colnames(simData.test)==ID)]
n = dim(simData_learn)[1] # number of non-zero entries
fit.expr.lin <- glmnet(x = log(1+simData_learn), y = log(1+vec.learn),
family = "gaussian", standardize = TRUE, alpha = 1)
?cv.glmnet
fit.expr.lin <- cv.glmnet(x = log(1+simData_learn), y = log(1+vec.learn),
family = "gaussian", standardize = TRUE, alpha = 1)
lasso.mixed.data <- function(ID,simData, genes = FALSE){
i = which(colnames(simData)==ID)
#formate for lasso function
simData <- as.matrix((simData))
#define test and learn data
simData.test <- simData[which(simData[,i]==0),,drop=FALSE] # define all zero entries of ID as test
simData.learn <- simData[-c(which(simData[,i]==0)),,drop=FALSE] # define all non-zero entries as learn
# take out ID from the data set for analysis
simData_learn <- simData.learn[,-c(which(colnames(simData.learn)==ID)),drop = FALSE]
simData_test <- simData.test[,-c(which(colnames(simData.test)==ID)),drop = FALSE]
#define the vector ID for analysis
vec.learn <- simData.learn[,which(colnames(simData.learn)==ID)]
vec.test <- simData.test[,which(colnames(simData.test)==ID)]
n = dim(simData_learn)[1] # number of non-zero entries
if (n > 2){ #if there is more than one entry non zero do regression
fit.expr.lin <- cv.glmnet(x = log(1+simData_learn), y = log(1+vec.learn),
family = "gaussian", standardize = TRUE, alpha = 1)
prediction <- predict(fit.expr.lin$glmnet.fit, newx = log(1+simData_test), s = fit.expr.lin$lambda.min)
prediction <- exp(prediction)-1
}else{
prediction <- rep(0, nrow(simData.test))
}
outputVector <- simData[,ID]
outputVector[which(simData[,ID]==0)] <- prediction
return(outputVector)
}
rc <- mapply(lasso.mixed.data, colnames(simData), MoreArgs = list((simData)))
simData2 <- simData
colnames(simData2) <- gsub("[ ,]", "", colnames(simData2), perl = TRUE)
td <- mapply(kknn.mixed.data, colnames(simData2),
MoreArgs = list(as.data.frame(simData2)))
Z <- magic(simData)
idcol.h <- grep("HUMAN", colnames(Z))
idrow.h <- grep("HUMAN", rownames(Z))
idcol.m <- grep("MOUSE", colnames(Z))
idrow.m <- grep("MOUSE", rownames(Z))
m <- colSums(Z[c(idrow.m,idrow.h),c(idcol.h,idcol.m)])/(dim(Z)[2]/2)
l <- colSums(rc[c(idrow.m,c(idcol.h,idcol.m)),c(idcol.h,idcol.m)])/(dim(Z)[2]/2)
k <- colSums(td[c(idrow.m,idrow.h),c(idcol.h,idcol.m)])/(dim(Z)[2]/2)
plot(m, type = "l", col = "green", ylim = c(0, max(c(m,l,k))))
lines(l, col = "red")
lines(k, col = "blue")
library(galoislattice)
?do_galois_lattice
G <- do_galois_lattice(M,label= "reduced")
plot(G)
Z <- graph.incidence(M)
plot(Z)
plot(G)
plot(Z)
plot(G)
G <- do_galois_lattice(M,label= "full")
plot(g)
plot(G)
?layout.fruchterman.reingold
library(devtools)
setwd("C:/Users/Maria/Desktop/MO/Arbeit/galoislattice")
document()
build()
check()
?head
?tail
document
document()
build()
check()
install()
